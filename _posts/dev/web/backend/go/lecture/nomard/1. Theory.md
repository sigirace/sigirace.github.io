## 1.0 Main Package

> ìë™ì ìœ¼ë¡œ ì»´íŒŒì¼ëŸ¬ëŠ” main packageì™€ ê·¸ ì•ˆì˜ main functionì„ ì°¾ê²Œ ë¨

### 1. main.go

- compileì„ ìˆ˜í–‰í•˜ëŠ” í”„ë¡œì íŠ¸ë¼ë©´ `main.go`ê°€ ë°˜ë“œì‹œ í•„ìš”
  - mainì´ ì§„ì…ì (entry point)
  - ì»´íŒŒì¼ëŸ¬ëŠ” íŒ¨í‚¤ì§€ ì´ë¦„ì´ mainì¸ ê²ƒ ë¶€í„° ì°¾ì•„ëƒ„
- ë¼ì´ë¸ŒëŸ¬ë¦¬ ê°™ì€ ê²½ìš°ì—ëŠ” í•„ìš” ì—†ìŒ

ğŸ“ **func main**

- goëŠ” íŠ¹ì •í•œ functionì„ ì°¾ê²Œë¨
- mainì´ í”„ë¡œê·¸ë¨ì˜ ì‹œì‘ì ì´ ë˜ëŠ” ë¶€ë¶„



## 1.1 Packages and Imports

### 1. Export Module

- functionì„ ë…¸ì¶œì‹œí‚¤ê³  ì‹¶ì„ ë•ŒëŠ” ëŒ€ë¬¸ìë¡œ ì‹œì‘í•¨
  - jsì—ì„œ í•¨ìˆ˜ ë…¸ì¶œì‹œ exportë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒê³¼ ê°™ìŒ



## 1.2 Variables and Constants

- goëŠ” íƒ€ì… ì–¸ì–´ì´ê¸°ì— ì–´ë–¤ íƒ€ì…ì¸ì§€ ì§€ì •í•´ì•¼í•¨
- constë¡œ ì§€ì •í•œ ë³€ìˆ˜ëŠ” ê°’ì„ ë³€ê²½í•  ìˆ˜ ì—†ìŒ
- varë¡œ ì§€ì •í•œ ë³€ìˆ˜ëŠ” ê°’ì„ ë³€ê²½í•  ìˆ˜ ìˆìŒ
  - shorthandìœ¼ë¡œ `:=`ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
  - shorthandëŠ” functionì•ˆì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥
  - ìë™ìœ¼ë¡œ íƒ€ì… ì¶”ë¡  ê°€ëŠ¥

ğŸŒˆ **ì˜ˆì‹œ**

```go
func main(){
  var firstName string = "shin"
  lastName := "kangsik"
}
```



## 1.3~1.4 Functions

### 1. basic

ğŸŒˆ **ì˜ˆì‹œ**

````go
func multiply(a, b int) int {
  return a * b
}
````

### 2. Multi Return

- goëŠ” multiple returnì´ ê°€ëŠ¥
- return ê°’ì„ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ ì—ëŸ¬ê°€ ë°œìƒ
- ì—ëŸ¬ë¥¼ ë¬´ì‹œí•˜ê¸° ìœ„í•´ì„œëŠ” ignore valueì¸ `_`(underline)ì„ ì‚¬ìš©

ğŸŒˆ **ì˜ˆì‹œ: multi return**

```go
func lenAndUpper(name string) (int, string){
  return len(name), strings.ToUpper(name)
}

func main() {
	totalLength, _ := lenAndUpper("nico")
	fmt.Println(totalLength)
}
```

### 3. Multi Input

- `...`ë¥¼ ì‚¬ìš©í•´ ì—¬ëŸ¬ ì¸ìë¥¼ ì…ë ¥í•¨ì„ ì•Œ ìˆ˜ ìˆìŒ
- ì—¬ëŸ¬ ì¸ìë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ì•„ ì¶œë ¥í•˜ë©´ arrayê°€ ë¨

ğŸŒˆ **ì˜ˆì‹œ: multi input**

```go
func repeatMe(words ...string){
  fmt.Println(words)
}

func main(){
  repeatMe("sigi", "kang", "shin")
}
```

```
[sigi kang shin]
```

### 4. Naked function

- ë°˜í™˜ ì •ì˜ì— ë¯¸ë¦¬ variableì„ ìƒì„±í•˜ê³  Update í•˜ëŠ” ë°©ì‹
- returnì´ ë°˜ë“œì‹œ í•„ìš”

ğŸŒˆ **ì˜ˆì‹œ**

```go
func lenAndUpper(name string) (length int, uppercase string){
  length = len(name)
  uppercase = strings.ToUpper(name)
  return
}

func main() {
	totalLength, _ := lenAndUpper("nico")
	fmt.Println(totalLength)
}
```

### 5. defer

- functionì´ ê°’ì„ returní•œ ë’¤ ì‹¤í–‰



## 1.5 for, range, ...args

### 1. for

- for ì´ì™¸ì— ë‹¤ë¥¸ ê²ƒì€ ì—†ìŒ
- range ë’¤ì—ëŠ” iterable ìë£Œí˜•ì´ ì˜¬ ìˆ˜ ìˆìŒ

ğŸŒˆ **ì˜ˆì‹œ**

```go
//type 1
for index, element := range elements {
  ...
}

//type 2
for i := 0; i < len(elements); i++ {
  ...
}
```

**ğŸ“Œ range ë’¤ì— ì˜¬ ìˆ˜ ìˆëŠ” ìë£Œí˜•**

| **íƒ€ì…**            | **ì„¤ëª…**                           |              |
| ------------------- | ---------------------------------- | ------------ |
| **ë°°ì—´ ([N]T)**     | ì •ì  í¬ê¸°ì˜ ë°°ì—´ì„ ìˆœíšŒ            | index, value |
| **ìŠ¬ë¼ì´ìŠ¤ ([]T)**  | ë™ì  í¬ê¸°ì˜ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ìˆœíšŒ        | index, value |
| **ë§µ (map[K]V)**    | í‚¤-ê°’ ìŒì„ ìˆœíšŒ                    | key, value   |
| **ì±„ë„ (chan T)**   | ì±„ë„ì—ì„œ ë°ì´í„°ë¥¼ êº¼ë‚´ë©´ì„œ ìˆœíšŒ    | value        |
| **ë¬¸ìì—´ (string)** | ë¬¸ìì—´ì˜ ê°œë³„ ë¬¸ì(ë£¬ rune)ì„ ìˆœíšŒ | index, value |





## 1.6~1.7 If, Switch

### 1. if

- `()` ë˜ëŠ” `:`ì´ í•„ìš” ì—†ìŒ

### 2.  variable expression

- if ë¬¸ ì•ˆì—ì„œ ë³€ìˆ˜ ìƒì„± ê°€ëŠ¥ `;`ë¥¼ ê¸°ì¤€ìœ¼ë¡œ êµ¬ë¶„
- if ë¬¸ ì•ˆì—ì„œë§Œ ì“°ì¼ ê²ƒì´ë¼ëŠ” ì˜ë¯¸ë¥¼ ê°€ì§€ê³  ìˆìŒ
- case ë¬¸ë„ switch ë’¤ì— variable expression ì‚¬ìš© ê°€ëŠ¥



## 1.8 Pointers

ğŸŒˆ **ì˜ˆì‹œ**

```go
func main() {
	a := 2
	b := &a
	a = 10
	fmt.Println(a, *b)
}
```

```
10 10
```

```go
func main() {
	a := 2
	b := a
	a = 10
	fmt.Println(a, b)
}
```

```
10 2
```



### ğŸš€ Call by Value vs Call by Reference

**ğŸ“Œ call by value**

- í•¨ìˆ˜ì— ê°’ì„ ë³µì‚¬í•´ì„œ ì „ë‹¬í•˜ëŠ” ë°©ì‹
- í•¨ìˆ˜ ë‚´ì—ì„œ ê°’ì„ ë³€ê²½í•´ë„ ì›ë³¸ ê°’ì´ ë³€ê²½ë˜ì§€ ì•ŠìŒ
- ê¸°ë³¸ ìë£Œí˜•ì´ í•´ë‹¹í•¨
  - int, float, string

ğŸŒˆ **ì˜ˆì‹œ**

```go
package main

import "fmt"

func changeValue(x int) {
    x = 10 // ê°’ ë³€ê²½
}

func main() {
    num := 5
    changeValue(num)
    fmt.Println(num) // ğŸ”¹ 5 (ê°’ì´ ë³€ê²½ë˜ì§€ ì•ŠìŒ)
}
```



**ğŸ“Œ call by reference**

- í•¨ìˆ˜ì— ë³€ìˆ˜ì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œ ì „ë‹¬
- í•¨ìˆ˜ ë‚´ì—ì„œ ê°’ì„ ë³€ê²½í•˜ë©´ ì›ë³¸ ê°’ë„ ë³€ê²½ë¨
- í¬ì¸í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì°¸ì¡° ì „ë‹¬

ğŸŒˆ **ì˜ˆì‹œ**

```go
package main

import "fmt"

func changeValue(x *int) {
    *x = 10 // í¬ì¸í„°ë¥¼ í†µí•´ ì›ë³¸ ê°’ ë³€ê²½
}

func main() {
    num := 5
    changeValue(&num) // &num -> numì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œ ì „ë‹¬
    fmt.Println(num) // ğŸ”¹ 10 (ê°’ì´ ë³€ê²½ë¨)
}
```

â¤ï¸â€ğŸ”¥ **sliceì™€ mapì€ Call by Referenceì²˜ëŸ¼ ë™ì‘**







## 1.9~1.10 Arrays, Slices and Map

### 1. Array

- ê¸°ë³¸ ë¬¸ë²•

```go
arr := [length or null]type{...elements}
```

### 2. Slice

- lengthê°€ nullì´ë©´ ì œí•œ ì—†ëŠ” arrì´ ë¨ -> slice
- sliceëŠ” ê¸°ë³¸ì ìœ¼ë¡œ Array
- `append`: sliceì— itemì„ ì¶”ê°€í•˜ê¸° ìœ„í•¨
- appendëŠ” ê°’ì„ ì¶”ê°€í•˜ëŠ” ê°œë…ì´ ì•„ë‹Œ, ìƒˆë¡œìš´ sliceë¥¼ ë°˜í™˜í•¨

ğŸŒˆ **ì˜ˆì‹œ**

```go
names := []string{"sigi", "kang"}
names = append(names, "shin")
```

### 3. Map

- ê¸°ë³¸ ë¬¸ë²•

```go
mapObject := map[keyType]valueType{"key1":"value", ...}
```

- ë‹¨ì ì¸ íƒ€ì…ì´ ì•„ë‹Œ ë™ì ìœ¼ë¡œ ë§Œë“¤ê¸° ìœ„í•´ì„œëŠ” `struct` í•„ìš”



## 1.11 Structs

- type ì •ì˜ê°€ í•„ìš”í•¨

```go
type example struct{
  var1	string
  var2	int
  var3	[]string
}

func main(){
  strArr := []string{"gogo", "lets"}
  tmp := example{var1: "var1", var2: 2, var3: strArr}
}
```



