### warm up

- 이전 수업에서는 데이터 분석을 위한 파이썬 코드들을 간단히 배워보았습니다.
- 지금부터 두시간동안은 파이썬을 데이터 분석의 강자로 만들게 해준 데이터 분석 툴인 판다스에 대해 배워볼건데요
- 시작은 가볍게 “Pandas가 뭐예요?“라는 질문으로 열어보겠습니다.



- 판다스라고 하면 저는 처음에 이렇게 귀여운 팬더 이미지가 생각이 나서 귀여운 녀석을 한번 넣어보았습니다.
- ‘Pandas’는 Python에서 데이터를 조작하고 분석하는 데 아주 강력한 **Python의 데이터 분석 라이브러리**입니다.
- 특히 대용량 데이터를 쉽고 빠르게 다룰 수 있도록 설계된 라이브러리예요.
- 우리가 흔히 사용하는 엑셀처럼 **표 형태의 데이터**, 즉 테이블 데이터를 다루는 데 최적화되어 있고요,
- 그래서 엑셀과 유사한 기능도 많이 갖추고 있습니다.
- 그림을 보면 뒤에 엑셀이 잔뜩 깔려있죠.



- 그럼 본격적으로 Pandas와 Excel을 비교해 보도록 하겠습니다.
- [읽기]
- 이처럼 Pandas는 단순히 데이터를 다루는 수준을 넘어서, **자동화**, **대규모 처리**, **시각화**, **확장성**까지 모두 고려할 수 있는 도구입니다.



- pandas 세트로 같이 묶여서 나오는 라이브러리 중 하나는 넘파이가 있습니다.
- Numpy는 숫자나 배열 계산에 특화된 Python 라이브러이며
- Pandas는 이 Numpy 위에서 만들어졌고, 덕분에 Pandas도 수치 계산이 빠르고 효율적입니다.
- 즉, Numpy는 **숫자 중심 계산**에 강하고, Pandas는 **표 형태 데이터(행/열 데이터)** 분석에 특화되어 있다고 보시면 됩니다.



- 이번 웜업은 Pandas의 개념을 아주 가볍게 맛보는 시간이었습니다.
- 앞으로 Pandas를 통해 여러분이 얼마나 쉽게, 또 강력하게 데이터를 다룰 수 있는지 직접 체험하시게 될 거예요.
- 그럼 본격적인 실습으로 들어가 보겠습니다! 🙌



[5:30]

## 실습

-  첫번째로 **Pandas의 기본 구조**에 대해 배워보겠습니다.

- Pandas에서 데이터를 다룰 때는 크게 두 가지 구조가 있습니다.

- 바로 **Series**와 **DataFrame**입니다.

- 먼저 **Series**부터 살펴볼게요.

- Series는 **1차원 배열** 구조입니다.

- 근데 단순한 배열이 아니라, 각 값에 **라벨**이 붙어 있다는 게 특징이에요.

  

- 예를 들어, 사과 대 400, 4 대 달러

- 이런 식으로, 데이터와 함께 그에 대한 라벨이 같이 있는 구조입니다.

- 이는 라벨이 단순히 순서가 아니라, **지정한 라벨을 기준으로 데이터에 접근할 수 있다**는 장점이 있어요.

- 앞서 배운 Python의 딕셔너리랑 비슷하게 생겼죠?



- 다음은 **DataFrame**입니다.
- DataFrame은 행과 열, 즉 **2차원 배열 구조**예요.
- 우리가 흔히 아는 **엑셀 테이블**과 거의 동일한 형태라고 보시면 됩니다.

- 즉, 시리즈에서는 데이터를 기준으로 라벨이 하나만 존재했다면 데이터프레임은 라벨이 행과 열에 모두 붙어있다고 볼 수 있습니다.
- 우리는 이 라벨을 통해 앞서 배운 인덱싱과 슬라이싱 개념을 적용해 데이터를 빠르게 찾을 수 있게 됩니다.
- 이떄 한가지 짚고 넘어가야 할 부분은 라벨과 데이터에는 어떠한 자료형도 들어갈 수 있다는 점입니다.



- 화면에 보이시는 표를 예로 들어 설명드리면,
- 김철수, 김영희라는 학생이 행의 라벨에 붙어있고 각각 **서울대, 고려대, 연세대**가 열의 라벨에 붙어 지원 결과가 들어있습니다.
- 행의 라벨에는 사람 이름이 열의 라벨은 대학 이름이 되는 구조죠.
- 여기서 눈여겨 볼 점은 라벨에는 동일한 데이터가 들어갈 수 있으며 각 셀에는 타입의 제한이 없는 다양한 데이터가 포함될 수 있다는 점입니다.
- 이 부분이 기존에 프로그램을 다루셨던 분들께서 파이썬의 유연함을 느낄수 있는 부분이라고 생각되네요.



### 3.2

- 그럼 이제 **DataFrame을 어떻게 다루는지** 간단히 설명드릴게요.
- DataFrame은 분석을 시작하기 전, **가장 먼저 데이터를 불러오고** 그 데이터를 **요약하거나**, **형태를 확인하거나**, **통계 정보를 확인**할 때 자주 사용됩니다.
- Pandas에서는 이러한 작업들을 쉽게 사용할 수 있도록 제공되기에 아주 편리합니다.
- 데이터 분석을 하다 보면 **데이터의 타입**도 바뀌는 경우가 있는데,
- Pandas는 이걸 자동으로 처리해주기도 하고, 우리가 직접 수정할 수도 있습니다.

### 3.2.1

- 그럼이제 판다스를 사용할 준비를 해보겠습니다.
- 앞서 배운 패키지를 불러오는 방식으로 판다스를 사용하게 될 것이구요
- 뒤에 as 부분은 판다스라는 용어를 매번 치기 귀찮으니 약어로 pd라고 별명을 붙여 사용하겠다는 의미입니다.



**📘 3.2.2 DataFrame 선언하기**

- 첫번째로는 Pandas에서 **DataFrame을 생성하는 방법**에 대해 알아보겠습니다.
- DataFrame을 만드는 방법은 여러 가지가 있지만, 오늘은 **가장 기본적인 두 가지 방식**을 소개해드릴게요.

**✅ Case 1. 배열 사용**

- 먼저 **배열을 사용해서 DataFrame을 생성하는 방법**입니다.

```
import pandas as pd

array = [['kor', 80], ['math', 70]]
```

- 자세히 들여다보면 앞서 배운 배열, 리스트 두개가 큰 리스트 하나에 포함되어있죠.
- 이러한 형태를 배열이 두개가 있기에 2차원 리스트라고 부르게 됩니다.
- 이 2차원 배열의 형태를 시각화하면 아래와 같구요.
- 이제 이를 데이터 프레임 형태로 선언하기 위해서는 아래와 같은 명령어를 사용하면 됩니다.

```
df = pd.DataFrame(array, columns=['subject', 'score'])
df
```

- 앞서 판다스 패키지에 별명 pd를 붙였고, 그 패키지 안에 있는 DataFrame이라는 클래스를 사용하겠다라는 의미이구요.
- 그 클래스로부터 인스턴스를 생성하기 위해 파라미터를 배열과 컬럼명을 넣어주게 됩니다.
- 이러한 과정을 거치면 우리는 Df라는 데이터 프레임을 얻게 되는데요.
- 이때 2차원 배열의 각각은 한 행을 의미하고, columns 인자는 열 이름을 지정하는 데 사용됩니다.
- 이처럼, **배열 기반**으로 생성할 때는 **행 중심**으로 데이터가 구성된다고 기억하면 좋을 것 같습니다.



**✅ Case 2. 딕셔너리 사용**

- 두 번째 방법은 **딕셔너리를 이용하는 방식**입니다.

```
df2 = pd.DataFrame({
    'subject': ['kor', 'math'],
    'score': [80, 70]
})
df2
```

- 동일하게 데이터프레임을 생성하기 위해 파라미터를 넣어주었는데요.
- 앞서 배운 딕셔너리 형태를 넣어줄수 있습니다.
- 이 방식은 **열(column) 중심의 구성**입니다.
- 딕셔너리의 **key**는 열 이름, **value**는 각 열의 데이터 목록이 됩니다.
- 결과는 앞서와 동일하게 출력됩니다.



- 정리를 하자면 **리스트 기반** 방식은 행 중심, **딕셔너리 기반** 방식은 열 중심입니다.
- 두 방식 모두 같은 결과를 만들 수 있지만, 상황에 따라 더 편리한 방법을 선택해서 사용할 수 있어요.
- 물론 딕셔너리 기반이 훨씬 가시성이 높긴 합니다.



[7:00 / 12:30]



**📘 3.2.3 DataFrame 출력하기 – 강의 스크립트**

- 이번에는 실제 데이터를 불러와서 **DataFrame 형태로 출력**해보는 실습을 진행하겠습니다.



- 이번 실습에서는 머신러닝 예제에서 자주 쓰이는 **붓꽃(iris)** 데이터를 사용하겠습니다.
- 먼저 아래 코드를 보시면 sklearn 패키지의 datasets 모듈의 load_iris 함수를 불러온 것을 볼 수 있습니다.
- 이 load_iris 함수를 통해 앞서 우리가 주가 데이터를 불러온 것 처럼 붗꽃 데이터를 불러올 수 있게 되는데요.
- 이는 머신러닝 연습용으로 많이 사용되며, 다양한 **꽃잎의 길이, 너비 등 측정값**이 포함되어 있습니다.

**🔧 실습 코드**

- 읽고 수행하기



- 전체 데이터를 다 보기엔 너무 많기 때문에,
- 앞부분 또는 뒷부분 일부만 미리 보고 싶을 땐 head() 또는 tail() 함수를 사용합니다.
- 이때, head()나 tail()에 인자값을 지정하지 않으면 기본값은 **5개**를 출력하여 보여줍니다.
- 여러개 보는것
- tail의 중요성

[4:30 / 17:00]



**📘 3.2.4 DataFrame 요약 및 통계 확인하기**

- 다음으로는 불러온 DataFrame에 담긴 iris 데이터를 요약하고, **기초 통계 정보를 확인**하는 방법에 대해 알아보겠습니다.
- 여기서 우리가 중점적으로 확인할 내용은 데이터에 어떤 **열(column)**이 있고, 각 열에 **몇 개의 값**이 있으며, 그 값들의 **분포와 요약 통계**가 어떤지 확인하는 것이 목적입니다.
- 먼저 info() 함수부터 확인해볼게요.
- 이 코드는 DataFrame의 **전체적인 구조를 요약**해 보여줍니다.
- 그럼 코드를 실행하고 확인해보겠습니다.

```
iris.info()
```

[해석]



- 다음으로 describe함수는 **각 열의 주요 통계 정보**를 보여줍니다.
- 통계 정보는 1강에서 말씀드린 평균, 표준편차 등을 나타내는 기술 통계량을 보여주게 되구요.
- 여기서 제가 주로 보는 데이터의 특성은 평균, 최소값, 최대값입니다.
- 최소값 최대값은 주로 이상 데이터가 들어있을 경우 눈에 확 띄기 때문에 가장 첫번째로 확인합니다.
- 다음으로는 평균과 표준편차를 비교해서 확인하는 편입니다.
- 아시다싶이 평균은 데이터의 대표값으로 주로 어디에 데이터가 몰려있는가를 판단할 수 있는 지표입니다.
- 그리고 표준편차는 데이터의 퍼짐 정도를 주로 파악하는데, 정확히는 평균에서부터 얼마나 데이터가 멀어져있냐 라는 것이죠.
- 저는 이 표준편차를 통해 보통 평균에 비해서 얼마나 값이 크냐, 작냐로 데이터가 sparse한지 dense한지를 파악합니다.
- 코드를 실행하고 확인해보겠습니다.

```
iris.describe()
```

[해석]

- 이를 수치로 확인하기 위해서 데이터의 범위와 비교할 수가 있는데 이를 상대적 표준편차라고 부릅니다.
- 상대적표준편차는 데이터가 전체 범위에 대해 얼마나 흩어져 있는지를 비율로 나타내구요
- 보통 0.1 이하면 매우 몰려있고, 0.3에서 0.5면 적당히 퍼져있으며, 0.6 이상이면 매우 넓게 퍼져있다고 볼 수 있습니다.
- 따라서 앞서 describe 함수를 통해 확인한 널리 퍼져있다고 의심되는 petal length 부분에 적용을 하여 본다면..

[실행]

- 비율이 약 0.3 정도 나오는 것을 볼 수 있는데요, 이 데이터는 적당히 분포되어있음을 볼 수 있겠네요
- 이처럼 describe는 데이터의 특성을 빠르게 파악하는 데 유용합니다.



- 다음으로는 더 알아보기가 나오는데요.
- 이는 추가적으로 생기는 의문에 대한 정리라고 보시면 됩니다.
- 저는 앞서 데이터의 요약 정보를 통해 다음과 같은 의문이 생겼습니다.
- “열마다 값의 범위가 다르면 분석에 영향이 있을까요?”
- 맞습니다.
- 예를 들어 어떤 컬럼, 특성은 은 0-1 사이, 어떤 컬럼은 100-1000 사이 값을 가진다면
- 모델이 큰 값을 가지는 범위의 특성을을 더 중요하다고 오해할 수 있습니다.
- 따라서 이럴 경우에는 **정규화나 표준화**와 같은 전처리로 각 컬럼의 스케일을 맞춰줄 필요가 있습니다.
- 이 과정은 뒤에서 자세히 다뤄보도록 하겠습니다.

- 이렇게 info()와 describe()는 데이터 분석에서 꼭 필요한 **기초 탐색 함수**입니다.
- 아마 pandas 강의에서 가장 중요한 부분이 아닐까 싶어요.
- 앞으로 분석할 데이터를 처음 접했을 때는 **무조건 이 두 함수부터 실행**하는 습관을 들이시면 좋습니다!

[08:00 / 25:00]



**📘 3.2.5 DataFrame 인덱스 핸들링**

- 이번에는 Pandas에서 **DataFrame의 인덱스를 자유롭게 다루는 방법**에 대해 알아보겠습니다.
- 인덱스는 앞서 데이터프레임의 라벨 중에 행 라벨을 다르게 부르는 말로 **각 행(row)의 고유한 위치를 나타내는 값**입니다.
- 기본적으로는 0부터 시작하는 정수형 인덱스가 자동 부여됩니다.
- 이를 데이터 프레임으로 다시 한번 확인해 보겠습니다.

- 여기서 왼쪽의 0, 1이 **기본 인덱스**입니다.

**📌 인덱스 확인 및 변경**

- 이제 인덱스 핸들링을 위해 인덱스만 확인해보도록 하겠습니다.
- 인덱스만 추출하는 방법은 데이터프레임 .index 명령어를 사용하시면 되구요
- 일반적으로 list 형식으로 출력하지 않으면 range 형태로 나오기에 
- list를 사용하여 인덱스가 배열 형태로 예쁘게 보이게 할 수 있습니다.

**🧪 인덱스 직접 지정**

- 다음으로는 인덱스를 원하는 형태로 바꾸는 방법입니다.
- 앞서 인덱스를 리스트로 뽑아낸 것처럼 새로운 인덱스를 리스트로 재지정하면 기존 인덱스를 우리가 직접 정한 값으로 바꿀 수 있게 됩니다.

**🛠️ set_index() 함수로 인덱스 설정**

- 다음으론 setindex 함수에 대해 알아보겠습니다.
- 이는 특정 **열(column)**을 인덱스로 사용하고 싶을 때 사용하게 되구요.
- 예시로 우리가 가지고 있는 데이터 프레임 컬럼에 날짜와 같은 데이터의 순서를 나타내는 것이 있을때 사용합니다.
- 해당 함수의 주요 파라미터는 다음과 같습니다.
- 보고 읽기



- 이제 이를 직접 실습해 보도록 하겠습니다.
- 데이터 프레임에서 과목에 대한 컬럼을 인덱스로 사용하며,
- 기존의 컬럼은 인덱스로 내림과 동시에 없앨 것이고
- 기존의 인덱스 또한 유지하지 않으며
- 원본 자체를 변경하겠다 라는 코드로 해석 될 수 있습니다.

🔄 reset_index() 함수로 인덱스 초기화

- 그런데 우리가 인덱스를 설정하고 나니 조금 이상하다.. 라고 생각되어 기존 인덱스를 **다시 숫자 인덱스로 초기화**하고 싶을 땐 reset_index()를 사용합니다.
- 이 함수에서 drop은 인덱스 열을 컬럼으로 복원할지 여부입니다.

- 코드를 실행하면 이처럼 인덱스를 다시 **일반 열로 되돌릴 수 있습니다.**



**📘 3.2.6 DataFrame의 열(column) 핸들링**

- 이번에는 **DataFrame의 열, 즉 컬럼을 다루는 방법**에 대해 알아보겠습니다.
- 앞서 행의 라벨은 인덱스라고 설명드렸는데 열의 라벨은 딱히 표현하는 것 없이 보통 컬럼이라고 부르곤 합니다.

**✅ 1. 컬럼 이름 확인하기**

- 먼저 현재 DataFrame에 어떤 컬럼들이 있는지 확인해봅시다.

**✅ 2. 컬럼 이름 변경하기**

- 우리는 컬럼의 명 또한 우리가 원하는 형태로 **일괄 변경**할 수 있습니다.
- 우리가 가진 아이리스 데이터의 컬럼은 뒤에 단위도 붙어있고, 공백도 있기에 데이터를 처리하기 쉽지 않습니다.
- 따라서 기존의 공백과 괄호 등을 제거하고 가독성 좋게 snake_case로 수정하도록 하겠습니다.
- python에는 아래 짝대기를 붙인 snake_case를 사용하는 것이 규칙이며, 이런 식으로 컬럼명을 일괄 수정하면 이후 데이터 다루기가 훨씬 편해집니다.

[6:00 / 31:00]



📘 3.2.7 DataFrame 컬럼의 데이터 타입 확인 및 변경

- 다음으로는 컬럼의 데이터 타입 확인 및 변경을 수행해보도록 하겠습니다.
- 데이터 타입은 분석 전 반드시 확인해야 할 중요한 정보입니다.
- 앞으로 전처리 과정에서 다양한 연산을 수행하게 될텐데, 형이 맞지 않는다면 오류가나기 때문이죠.
- 이는 앞서 파이썬 기초 강의에서 형변환 과정을 통해 확인할 수 있었습니다.
- 데이터 프레임에서 사용하는 데이터 타입을 말씀드리자면
- int는 정수 float은 실수 bool은 True/False datetime은 날짜/시간 그리고 그외 스트링을 포함한 데이터 자료형들은 object로 표현됩니다.



1. 타입 확인

- 먼저 dtypes 속성으로 데이터 타입을 확인할 수 있습니다.

**✅ 2. 타입 변경하기: astype()**

- 다음은 타입 변경입니다.
- 앞서 파이썬 과정에서 단일 자료형의 타입을 변경하려면 앞에 변경하고 싶은 타입을 적어주었습니다.
- 하지만 데이터 프레임의 컬럼의 타입을 변경하고 싶으면 astype 함수를 사용하고 파라미터로 타입을 문자열로 넣어주면 됩니다.

[코드]

- ⚠️ 단, astype으로 바꿀 때는 **데이터 손실 여부**에 주의해야 합니다.
- 예시로 실수 → 정수로 바꿀 경우 소수점이 잘려 나가기 때문이죠.

[2:30 / 33:30]



**📘 3.3 row / column 핸들링**

- 지금까지는 행과 열의 라벨을 핸들링 하는 방법에 대해 배워보았는데요

- 이번에는 라벨을 통해 조회하는 방법을 알아보겠습니다.

  

**🔹 3.3.1 row / column 선택 조회**

**✅ 1. 행(row) 선택 – 슬라이싱**

- 먼저 DataFrame에서 행 라벨, 인덱스를 기준으로 조회하고 싶을 땐 슬라이싱을 사용합니다.
- 슬라이싱의 개념은 처음부터 끝 직전까지라고 말씀을 드렸습니다.

[코드]

**✅ 2. 열(column) 선택 – 열 이름 사용**

- 다음으로는 특정 컬럼을 선택해서 조회해보도록 하겠습니다.
- 이는 컬럼명 또는 컬럼명의 리스트를 사용하는데요
- 키 포인트로 컬럼명은 시리즈를 반환하며 컬럼명 리스트는 데이터 프레임을 반환한다 라고 적어놓았습니다.
- 직관적으로는 데이터 프레임에서 조회했으니 데이터 프레임이 될 것 같은데
- 앞서 단일 배열에 대한 것은 데이터프레임이라고 표현하지 않고 시리즈라고 말씀드렸습니다.
- 따라서 하나의 열만 조회하게 된다면 반환되는 타입은 시리즈임을 유의해 주세요.

[코드]



- 다음으로는 복수 열을 조회해 보도록 하겠습니다.

[코드]

- 이런식으로 리스트로 여러 열을 넘기면 결과는 **DataFrame**임을 확인 할 수 있습니다.

**🔹 3. row와 column 동시 선택**

- 다음으로는 행과 열 라벨을 둘다 사용해서 조회는 방식입니다.
- 이를 위해 아주 아주 헷갈리는 iloc과 loc이 등장하게 되는데요.
- 한번에 개념을 잡고 잊어버리지 않게 상세히 설명해드리도록 하겠습니다.



**✅ 3-1. .iloc[] – 인덱스를 기준으로 선택**

- 먼저 iloc입니다. 
- I가 붙었죠, 이 i는 integer 즉 숫자라고 생각해 주세요.
- 그래서 iloc은 정수로 특정 행과 열을 선택하여 조회하고 싶은 경우에 사용합니다.
- 정수는 데이터 프레임에서 행과 열의 위치를 의미하게 됩니다.
- 이때 데이터프레임에서 위치는 0번째 부터 시작이라는 것을 기억해주세요.

- 그럼 사용 방법을 알아보도록 하겠습니다.
- iloc의 인수로 row와 column이 있는 것을 볼 수 있습니다.
- 이때 이 둘은 쉼표로 구분되어 있는 것을 꼭 기억해 주세요.
- 만약 iloc의 인수로 숫자가 들어가있는데 쉼표가 없는 경우, 행만을 사용하겠다는 의미이구요
- 쉼표가 있는 경우에는 행과 열 둘 다 사용하겠다는 의미가 됩니다.
- 인수로는 정수, 리스트 슬라이싱이 들어갈 수 있다고 하는데 실습을 통해 확인해 보도록 하겠습니다.

[코드]

- 우리는 iris 데이터 프레임에서 iloc을 사용해 특정 데이터를 조회할 것입니다.

- 이때 쉼표가 없기에 행 기준으로만 조회를 할것이구요

- 위치상으로 0번째부터 2번째 직전, 즉 1까지를 조회하겠습니다.

  

- iloc은 정수를 사용하니 위치 즉,~번째위치로 생각하면 쉽다! 라는 것을 기억해주시구요



**✅ 3-2. .loc[] – 레이블(이름)을 기준으로 선택**

- 다음은 loc입니다.
- 대부분의 내용은 iloc과 같으나 차이점은 loc은 위치가 아닌 라벨 기준으로 선택이됩니다.
- 그래서 정수 뿐만 아니라, 문자열인 라벨 또한 사용할 수 있습니다.
- 또한, 중요한점이 슬라이싱의 개념이 달라지게 됩니다.
- 이전까지는 시작부터 끝 직전까지라는 의미였지만, loc에서의 슬라이싱은 진짜 끝까지 라는 점을 기억해주세요.
- 이에 대한 이유는 실습과 함께 설명드리도록 하겠습니다.
- 일단, 사용법은 iloc과 같으니 바로 코드로 넘어가도록 하겠습니다.

- 먼저 라벨 기준으로 데이터를 가져오는 것을 확인하기 위해 인덱스를 변경해보도록 하겠습니다.
- 위치 개념과 헷갈리지 않게 라벨을 특정한 문자열로 변경하도록 하겠습니다.

[코드]

- 먼저 인덱스 배열을 가져오고 배열에서 두번째 인덱스, 데이터 프레임의 인덱스가 아닙니다.
- 배열의 두번째 인덱스, 세번쨰위치가 되겠죠
- 이를 파이썬으로 변경할 것입니다.
- 그리고 배열의 슬라이싱을 통해 확인해보면 전체 배열에서 인덱스 2, 세번째 위치에 있는 값이 잘 변경됨을 알 수 있습니다.

[코드]

- 그리고 이 배열을 사용해 전체 인덱스를 변경하고 상위 5개 데이터만 확인화는 head를 사용해 출력하면
- 데이터 프레임의 행 라벨 중 3번째 위치한 것이 파이썬으로 변경됨을 확인할 수 있습니다.

[코드]

- 이제 라벨이 0인 행부터 파이썬인 행까지 슬라이싱을 통해 조회해 보겠습니다.
- 여기서 알 수 있는 점은 라벨 기준으로 슬라이싱을 수행할때, 기존 파이썬의 슬라이싱처럼 끝 직전까지 라는 의미가 어렵다는 것을 알 수 있습니다.
- 기존에는 슬라이싱에 사용되는 인덱스가 숫자로 위치를 나타냈기에 끝 직전이라는 것을 알 수 있었지만,
- Loc에서 사용하는 슬라이싱에는 문자열을 사용할 수 있기에 파이썬이 위치를 알기 어렵기 때문입니다.
- 그래서 loc을 사용하는 인덱싱은 시작부터 끝까지라는 의미를 가질 수 밖에 없습니다.

[코드]]

- 컬럼명도 슬라이스로 지정할 수 있습니다.
- 쉼표를 기준으로 왼쪽은 행 오른쪽은 열이되며 열에대한 슬라이싱이 세팔 위드부터 페탈 위드까지 수행한 된 것을 확인할 수 있습니다.

**✅ 4. 선택한 값 변경하기**

- 이런식으로 행과 열을 모두 사용하게 된다면 특정 위치의 값, 엑셀에서는 셀을 지정할 수 있고
- 해당 값만을 변경할 수 있습니다.
- 여기에서는 라벨 기준으로 데이터를 지정하는 loc을 사용해 파이썬 행의 세팔 렝스 열을 100으로 값 변경을 수행해 보겠습니다.
- 네 값이 잘 바뀐 것을 확인할 수 있습니다.

[10:00 / 43:00]



**📘 3.3.2 row / column Concat **

- 이제 데이터를 가져오는 방법을 알았으니 데이터를 조합하는 방법을 알아볼 텐데요
- 첫번째로 두 개 이상의 DataFrame을 **붙이는 방법**, 즉 concat()을 사용하는 방법을 배워보겠습니다.
- concat은 **행(row)** 또는 **열(column)** 방향으로 데이터를 연결할 수 있도록 해주는 함수입니다.

**🔧 concat() 함수 구조**

- 컨켓 함수의 파라미터는 다음과 같습니다.
- 읽기
- 코드까지 읽어야함



[3:00/ 46:00]



**📘 3.3.3 row / column 삭제 – 강의 스크립트**

- 이제 데이터를 붙여보았으니 떼보기도 해야겠죠 이번에는 Pandas의 drop() 함수를 사용하여
- **특정 행(row) 또는 열(column)** 을 삭제하는 방법을 배워보겠습니다.

**✅ 1. drop() 함수 기본 설명**

```
DataFrame.drop(index=None, columns=None, inplace=False)
```

- drop api의 파라미터는 다음과 같습니다.
- 읽기



**✅ 2. 행(row) 삭제 – index 기준**

- 먼저 행을 삭제하기 위해서는 인덱스를 기준으로 삼아야 합니다.
- '엄친아'라는 인덱스를 가진 행을 삭제해 보겠습니다.

```
score = score.drop('엄정아', inplace=False)
```

- inplace=False이므로 원본은 그대로이고, 결과만 출력됩니다.



**✅ 3. 열(column) 삭제 – columns 기준**

```
score = score.drop(columns=['과학'], inplace=False)
```

- 다음으로 '과학' 열 전체를 삭제하는 예시입니다.



- 데이터 삭제는 간단히 drop이라는 api를 사용해 쉽게 진행할 수 있음을 확인했습니다.



[끝]



- 네 이렇게 일단 pandas 기초 첫 시간은 마무리하도록 하구요
- 잠시 쉬었다가 다음시간부터 이어나가도록 하겠습니다.





---



- 하나만 더 확인을 해보도록 할까요?
- 만약 데이터가 가진 길이가 서로 다르다면 어떻게 될까요?
- [코드 작성]
- 아 에러가 나게 되네요, 기본적으로 판다스에서 자동으로 길이를 맞춰서 데이터 프레임을 맞춰주는 방식은 없습니다.
- 그래서 이럴 경우 보통 먼저 데이터의 길이를 선행적으로 파악하여야 하는 경우가 발생합니다.
- 만약 이것도 자동으로 맞춰줘! 라는 기능이 필요하다면
- zip_longest라는 방식을 사용할 수 있는데요 코드는 이러합니다.

```python
from itertools import zip_longest

data = list(zip_longest(['kor', 'math'], [80, 70, 100]))
df3 = pd.DataFrame(data, columns=['subject', 'score'])
df3
```

- 그런데 데이터들은 어떠한 인덱스를 기준으로 맞춰주는 경우가 대부분이고
- 이런식으로 단순 데이터의 나열만 가진 데이터는 거의 없기 때문에 잘 사용하지는 않는 것 같습니다.
